{"ast":null,"code":"!function (e, t) {\n  \"object\" == typeof exports && \"undefined\" != typeof module ? t(exports, require(\"react\")) : \"function\" == typeof define && define.amd ? define([\"exports\", \"react\"], t) : t((e = \"undefined\" != typeof globalThis ? globalThis : e || self)[\"react-horizontal-scrolling-menu\"] = {}, e.React);\n}(this, function (e, t) {\n  \"use strict\";\n\n  function n(e) {\n    return e && \"object\" == typeof e && \"default\" in e ? e : {\n      default: e\n    };\n  }\n\n  var r = n(t);\n  !function (e, t) {\n    void 0 === t && (t = {});\n    var n = t.insertAt;\n\n    if (e && \"undefined\" != typeof document) {\n      var r = document.head || document.getElementsByTagName(\"head\")[0],\n          o = document.createElement(\"style\");\n      o.type = \"text/css\", \"top\" === n && r.firstChild ? r.insertBefore(o, r.firstChild) : r.appendChild(o), o.styleSheet ? o.styleSheet.cssText = e : o.appendChild(document.createTextNode(e));\n    }\n  }(\".react-horizontal-scrolling-menu--wrapper {\\n  display: flex;\\n}\\n\\n.react-horizontal-scrolling-menu--scroll-container {\\n  display: flex;\\n  height: max-content;\\n  overflow-y: hidden;\\n  position: relative;\\n  width: 100%;\\n}\\n\\n:export {\\n  wrapper: react-horizontal-scrolling-menu--wrapper;\\n  container: react-horizontal-scrolling-menu--scroll-container;\\n}\\n\");\n  const o = \"react-horizontal-scrolling-menu\",\n        i = \"-separator\",\n        l = `${o}--separator`,\n        a = `${o}--item`,\n        s = `${o}--scroll-container`,\n        u = `${o}--wrapper`,\n        d = \"itemId\",\n        c = \"data-key\",\n        f = \"data-index\";\n  var v = Object.freeze({\n    __proto__: null,\n    rootClassName: o,\n    separatorString: i,\n    separatorClassName: l,\n    itemClassName: a,\n    scrollContainerClassName: s,\n    wrapperClassName: u,\n    id: d,\n    dataKeyAttribute: c,\n    dataIndexAttribute: f\n  });\n\n  function m(_ref) {\n    let {\n      className: e = \"\",\n      children: t,\n      onScroll: n = () => {},\n      scrollRef: o\n    } = _ref;\n    const i = r.default.useMemo(() => `${s} ${e}`, [e]);\n    return r.default.createElement(\"div\", {\n      className: i,\n      onScroll: n,\n      ref: o\n    }, t);\n  }\n\n  var h = r.default.memo(function (_ref2) {\n    let {\n      className: e,\n      id: t,\n      index: n,\n      refs: o\n    } = _ref2;\n    const i = r.default.useRef(null);\n    return o[n] = i, r.default.createElement(\"div\", Object.assign({\n      className: e\n    }, {\n      [c]: t,\n      [f]: n\n    }, {\n      ref: i\n    }));\n  });\n  var p,\n      g = r.default.memo(function (_ref3) {\n    let {\n      children: e,\n      className: t,\n      id: n,\n      index: o,\n      refs: i\n    } = _ref3;\n    const l = r.default.useRef(null);\n    return i[String(o)] = l, r.default.createElement(\"div\", Object.assign({\n      className: t\n    }, {\n      [c]: n,\n      [f]: o\n    }, {\n      ref: l\n    }), e);\n  });\n\n  function b(_ref4) {\n    let {\n      children: e,\n      itemClassName: t = \"\",\n      refs: n,\n      separatorClassName: o = \"\"\n    } = _ref4;\n    const s = r.default.Children.toArray(e).filter(Boolean),\n          u = s.length,\n          c = r.default.useMemo(() => `${a} ${t}`, [t]),\n          f = r.default.useMemo(() => `${l} ${o}`, [o]);\n    return r.default.createElement(r.default.Fragment, null, s.map((e, t) => {\n      var o, l;\n      const a = null === (l = null === (o = e) || void 0 === o ? void 0 : o.props) || void 0 === l ? void 0 : l[d],\n            s = a + i,\n            v = t + 1 === u;\n      return [r.default.createElement(g, {\n        className: c,\n        id: a,\n        key: \"menuItem__\" + a,\n        refs: n,\n        index: t\n      }, e), !v && r.default.createElement(h, {\n        className: f,\n        id: s,\n        refs: n,\n        key: s,\n        index: t + .1\n      })];\n    }));\n  }\n\n  function y(e) {\n    return \"object\" == typeof e && null != e && 1 === e.nodeType;\n  }\n\n  function w(e, t) {\n    return (!t || \"hidden\" !== e) && \"visible\" !== e && \"clip\" !== e;\n  }\n\n  function x(e, t) {\n    if (e.clientHeight < e.scrollHeight || e.clientWidth < e.scrollWidth) {\n      var n = getComputedStyle(e, null);\n      return w(n.overflowY, t) || w(n.overflowX, t) || function (e) {\n        var t = function (e) {\n          if (!e.ownerDocument || !e.ownerDocument.defaultView) return null;\n\n          try {\n            return e.ownerDocument.defaultView.frameElement;\n          } catch (e) {\n            return null;\n          }\n        }(e);\n\n        return !!t && (t.clientHeight < e.scrollHeight || t.clientWidth < e.scrollWidth);\n      }(e);\n    }\n\n    return !1;\n  }\n\n  function I(e, t, n, r, o, i, l, a) {\n    return i < e && l > t || i > e && l < t ? 0 : i <= e && a <= n || l >= t && a >= n ? i - e - r : l > t && a < n || i < e && a > n ? l - t + o : 0;\n  }\n\n  function E(e, t) {\n    var n = window,\n        r = t.scrollMode,\n        o = t.block,\n        i = t.inline,\n        l = t.boundary,\n        a = t.skipOverflowHiddenElements,\n        s = \"function\" == typeof l ? l : function (e) {\n      return e !== l;\n    };\n    if (!y(e)) throw new TypeError(\"Invalid target\");\n\n    for (var u = document.scrollingElement || document.documentElement, d = [], c = e; y(c) && s(c);) {\n      if ((c = c.parentElement) === u) {\n        d.push(c);\n        break;\n      }\n\n      null != c && c === document.body && x(c) && !x(document.documentElement) || null != c && x(c, a) && d.push(c);\n    }\n\n    for (var f = n.visualViewport ? n.visualViewport.width : innerWidth, v = n.visualViewport ? n.visualViewport.height : innerHeight, m = window.scrollX || pageXOffset, h = window.scrollY || pageYOffset, p = e.getBoundingClientRect(), g = p.height, b = p.width, w = p.top, E = p.right, C = p.bottom, M = p.left, N = \"start\" === o || \"nearest\" === o ? w : \"end\" === o ? C : w + g / 2, S = \"center\" === i ? M + b / 2 : \"end\" === i ? E : M, k = [], O = 0; O < d.length; O++) {\n      var A = d[O],\n          T = A.getBoundingClientRect(),\n          j = T.height,\n          W = T.width,\n          R = T.top,\n          V = T.right,\n          $ = T.bottom,\n          B = T.left;\n      if (\"if-needed\" === r && w >= 0 && M >= 0 && C <= v && E <= f && w >= R && C <= $ && M >= B && E <= V) return k;\n\n      var L = getComputedStyle(A),\n          H = parseInt(L.borderLeftWidth, 10),\n          D = parseInt(L.borderTopWidth, 10),\n          P = parseInt(L.borderRightWidth, 10),\n          _ = parseInt(L.borderBottomWidth, 10),\n          z = 0,\n          X = 0,\n          Y = \"offsetWidth\" in A ? A.offsetWidth - A.clientWidth - H - P : 0,\n          q = \"offsetHeight\" in A ? A.offsetHeight - A.clientHeight - D - _ : 0;\n\n      if (u === A) z = \"start\" === o ? N : \"end\" === o ? N - v : \"nearest\" === o ? I(h, h + v, v, D, _, h + N, h + N + g, g) : N - v / 2, X = \"start\" === i ? S : \"center\" === i ? S - f / 2 : \"end\" === i ? S - f : I(m, m + f, f, H, P, m + S, m + S + b, b), z = Math.max(0, z + h), X = Math.max(0, X + m);else {\n        z = \"start\" === o ? N - R - D : \"end\" === o ? N - $ + _ + q : \"nearest\" === o ? I(R, $, j, D, _ + q, N, N + g, g) : N - (R + j / 2) + q / 2, X = \"start\" === i ? S - B - H : \"center\" === i ? S - (B + W / 2) + Y / 2 : \"end\" === i ? S - V + P + Y : I(B, V, W, H, P + Y, S, S + b, b);\n        var F = A.scrollLeft,\n            J = A.scrollTop;\n        N += J - (z = Math.max(0, Math.min(J + z, A.scrollHeight - j + q))), S += F - (X = Math.max(0, Math.min(F + X, A.scrollWidth - W + Y)));\n      }\n      k.push({\n        el: A,\n        top: z,\n        left: X\n      });\n    }\n\n    return k;\n  }\n\n  function C(e) {\n    return e === Object(e) && 0 !== Object.keys(e).length;\n  }\n\n  function M(e, t) {\n    var n = !e.ownerDocument.documentElement.contains(e);\n    if (C(t) && \"function\" == typeof t.behavior) return t.behavior(n ? [] : E(e, t));\n\n    if (!n) {\n      var r = function (e) {\n        return !1 === e ? {\n          block: \"end\",\n          inline: \"nearest\"\n        } : C(e) ? e : {\n          block: \"start\",\n          inline: \"nearest\"\n        };\n      }(t);\n\n      return function (e, t) {\n        void 0 === t && (t = \"auto\");\n        var n = (\"scrollBehavior\" in document.body.style);\n        e.forEach(function (e) {\n          var r = e.el,\n              o = e.top,\n              i = e.left;\n          r.scroll && n ? r.scroll({\n            top: o,\n            left: i,\n            behavior: t\n          }) : (r.scrollTop = o, r.scrollLeft = i);\n        });\n      }(E(e, r), r.behavior);\n    }\n  }\n\n  var N = function () {\n    return p || (p = \"performance\" in window ? performance.now.bind(performance) : Date.now), p();\n  };\n\n  function S(e) {\n    var t = N(),\n        n = Math.min((t - e.startTime) / e.duration, 1),\n        r = e.ease(n),\n        o = e.startX + (e.x - e.startX) * r,\n        i = e.startY + (e.y - e.startY) * r;\n    e.method(o, i), o !== e.x || i !== e.y ? requestAnimationFrame(function () {\n      return S(e);\n    }) : e.cb();\n  }\n\n  function k(e, t, n, r, o, i) {\n    var l, a, s;\n    void 0 === r && (r = 600), void 0 === o && (o = function (e) {\n      return 1 + --e * e * e * e * e;\n    }), l = e, a = e.scrollLeft, s = e.scrollTop, S({\n      scrollable: l,\n      method: function (t, n) {\n        e.scrollLeft = Math.ceil(t), e.scrollTop = Math.ceil(n);\n      },\n      startTime: N(),\n      startX: a,\n      startY: s,\n      x: t,\n      y: n,\n      duration: r,\n      ease: o,\n      cb: i\n    });\n  }\n\n  var O = function (e, t) {\n    var n = t || {};\n    return function (e) {\n      return e && !e.behavior || \"smooth\" === e.behavior;\n    }(n) ? M(e, {\n      block: n.block,\n      inline: n.inline,\n      scrollMode: n.scrollMode,\n      boundary: n.boundary,\n      behavior: function (e) {\n        return Promise.all(e.reduce(function (e, t) {\n          var r = t.el,\n              o = t.left,\n              i = t.top,\n              l = r.scrollLeft,\n              a = r.scrollTop;\n          return l === o && a === i ? e : [].concat(e, [new Promise(function (e) {\n            return k(r, o, i, n.duration, n.ease, function () {\n              return e({\n                el: r,\n                left: [l, o],\n                top: [a, i]\n              });\n            });\n          })]);\n        }, []));\n      }\n    }) : Promise.resolve(M(e, t));\n  };\n\n  function A(e, t, n, r, o) {\n    var i, l;\n    const a = (null === (l = null === (i = e) || void 0 === i ? void 0 : i.entry) || void 0 === l ? void 0 : l.target) || e,\n          s = t || \"smooth\";\n    return a && O(a, Object.assign({\n      behavior: s,\n      inline: n || \"end\",\n      block: r || \"nearest\",\n      duration: 500\n    }, o));\n  }\n\n  const T = e => document.querySelector(`[data-key='${e}']`),\n        j = e => document.querySelector(`[data-index='${e}']`);\n\n  function W(e) {\n    return r.default.isValidElement(e) && e || \"function\" == typeof e && r.default.createElement(e, null) || null;\n  }\n\n  const R = e => e.filter(e => !new RegExp(\".*-separator$\").test(e)),\n        V = \"undefined\" != typeof window ? r.default.useLayoutEffect : r.default.useEffect;\n\n  function $(_ref5) {\n    let {\n      items: e,\n      itemsChanged: t,\n      refs: n,\n      options: o\n    } = _ref5;\n    const i = r.default.useRef(),\n          [l, a] = r.default.useState([]),\n          s = r.default.useRef(+setTimeout(() => {}, 0)),\n          u = r.default.useCallback(t => {\n      e.set(function (e, t) {\n        return [...e].map(e => {\n          var n, r;\n          const o = e.target,\n                i = (null === (n = null == o ? void 0 : o.dataset) || void 0 === n ? void 0 : n.key) || \"\";\n          return [i, {\n            index: String((null === (r = null == o ? void 0 : o.dataset) || void 0 === r ? void 0 : r.index) || \"\"),\n            key: i,\n            entry: e,\n            visible: e.intersectionRatio >= t.ratio\n          }];\n        });\n      }(t, o)), global.clearTimeout(s.current), s.current = +setTimeout(() => global.requestAnimationFrame(() => {\n        a(t => {\n          const n = e.getVisible().map(e => e[1].key);\n          return JSON.stringify(t) !== JSON.stringify(n) ? n : t;\n        });\n      }), o.throttle);\n    }, [e, o]);\n    return V(() => {\n      const e = (e => Object.values(e).map(e => e.current).filter(Boolean))(n),\n            t = i.current || new IntersectionObserver(u, o);\n\n      return i.current = t, e.forEach(e => t.observe(e)), () => {\n        clearTimeout(s.current), t.disconnect(), i.current = void 0;\n      };\n    }, [u, t, o, n]), {\n      visibleItems: l\n    };\n  }\n\n  function B(e, t) {\n    const [n, o] = r.default.useState(\"\"),\n          i = r.default.useMemo(() => {\n      return t = e, r.default.Children.toArray(t).map(e => {\n        var t, n;\n        return null === (n = null === (t = e) || void 0 === t ? void 0 : t.props) || void 0 === n ? void 0 : n[d];\n      }).filter(Boolean);\n      var t;\n    }, [e]);\n    return r.default.useEffect(() => {\n      const e = i.filter(Boolean).join(\"\");\n      t.toItemsWithoutSeparators().filter(e => !i.includes(e)).forEach(e => {\n        var n, r;\n        const o = (null === (n = t.last()) || void 0 === n ? void 0 : n.key) === e && (null === (r = t.prev(e)) || void 0 === r ? void 0 : r.key) || \"\";\n        t.delete(o), t.delete(`${e}-separator`), t.delete(e);\n      }), o(e);\n    }, [i, t]), n;\n  }\n\n  class L extends Map {\n    toArr() {\n      return this.sort([...this]);\n    }\n\n    toItems() {\n      return this.toArr().map(_ref6 => {\n        let [e] = _ref6;\n        return e;\n      });\n    }\n\n    toItemsWithoutSeparators() {\n      return R(this.toItems());\n    }\n\n    toItemsKeys() {\n      return this.toItems();\n    }\n\n    sort(e) {\n      return e.sort((_ref7, _ref8) => {\n        let [, e] = _ref7;\n        let [, t] = _ref8;\n        return +e.index - +t.index;\n      });\n    }\n\n    set(e, t) {\n      return Array.isArray(e) ? this.sort(e).forEach(_ref9 => {\n        let [e, t] = _ref9;\n        super.set(e, t);\n      }) : super.set(e, t), this;\n    }\n\n    first() {\n      var e;\n      return null === (e = this.toArr()[0]) || void 0 === e ? void 0 : e[1];\n    }\n\n    last() {\n      var e, t;\n      return null === (t = null === (e = this.toArr().slice(-1)) || void 0 === e ? void 0 : e[0]) || void 0 === t ? void 0 : t[1];\n    }\n\n    filter(e) {\n      return this.toArr().filter(e);\n    }\n\n    find(e) {\n      return this.toArr().find(e);\n    }\n\n    findIndex(e) {\n      return this.toArr().findIndex(e);\n    }\n\n    prev(e) {\n      var t;\n      const n = this.toArr(),\n            r = n.findIndex(_ref10 => {\n        let [t, n] = _ref10;\n        return t === e || n === e;\n      });\n      return -1 !== r ? null === (t = n[r - 1]) || void 0 === t ? void 0 : t[1] : void 0;\n    }\n\n    next(e) {\n      var t;\n      const n = this.toArr(),\n            r = n.findIndex(_ref11 => {\n        let [t, n] = _ref11;\n        return t === e || n === e;\n      });\n      return -1 !== r ? null === (t = n[r + 1]) || void 0 === t ? void 0 : t[1] : void 0;\n    }\n\n    getVisible() {\n      return this.filter(e => e[1].visible);\n    }\n\n  }\n\n  const H = {\n    ratio: .9,\n    rootMargin: \"5px\",\n    threshold: [.05, .5, .75, .95],\n    throttle: 100\n  };\n\n  const D = r.default.createContext({}),\n        P = e => e.reduce((e, t) => e.concat(t).concat(`${t}-separator`), []).slice(0, -1);\n\n  e.ScrollMenu = function (_ref12) {\n    let {\n      LeftArrow: e,\n      RightArrow: t,\n      children: n,\n      transitionDuration: o = 500,\n      transitionEase: i,\n      transitionBehavior: l,\n      onInit: a = () => {},\n      onUpdate: s = () => {},\n      onMouseDown: d,\n      onMouseUp: c,\n      onMouseMove: f,\n      onScroll: v = () => {},\n      onWheel: h = () => {},\n      options: p = H,\n      scrollContainerClassName: g = \"\",\n      itemClassName: y = \"\",\n      separatorClassName: w = \"\",\n      wrapperClassName: x = \"\",\n      apiRef: I = {\n        current: {}\n      }\n    } = _ref12;\n\n    const E = W(e),\n          C = W(t),\n          M = r.default.useRef(null),\n          [N] = r.default.useState({}),\n          S = r.default.useMemo(() => Object.assign(Object.assign(Object.assign({}, H), p), {\n      root: M.current\n    }), [p, M.current]),\n          k = r.default.useRef(new L()).current,\n          O = B(n, k),\n          {\n      visibleItems: V\n    } = $({\n      items: k,\n      itemsChanged: O,\n      options: S,\n      refs: N\n    }),\n          P = !!V.length,\n          _ = r.default.useMemo(() => function (e) {\n      let t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n      let n = arguments.length > 2 ? arguments[2] : undefined;\n      let r = arguments.length > 3 ? arguments[3] : undefined;\n      var o, i;\n\n      const l = R(t),\n            a = !!(null === (o = e.first()) || void 0 === o ? void 0 : o.visible),\n            s = !!(null === (i = e.last()) || void 0 === i ? void 0 : i.visible),\n            u = t => {\n        var n;\n        return null === (n = e.find(e => e[1].key === String(t))) || void 0 === n ? void 0 : n[1];\n      },\n            d = () => {\n        var t, n;\n        return e.prev(null === (n = null === (t = e.getVisible()) || void 0 === t ? void 0 : t[0]) || void 0 === n ? void 0 : n[1]);\n      },\n            c = () => {\n        var t, n, r, o;\n        return e.next(null === (o = null === (r = null === (n = null === (t = e.getVisible()) || void 0 === t ? void 0 : t.slice) || void 0 === n ? void 0 : n.call(t, -1)) || void 0 === r ? void 0 : r[0]) || void 0 === o ? void 0 : o[1]);\n      };\n\n      return {\n        getItemById: u,\n        getItemElementById: T,\n        getItemByIndex: t => {\n          var n;\n          return null === (n = e.find(e => String(e[1].index) === String(t))) || void 0 === n ? void 0 : n[1];\n        },\n        getItemElementByIndex: j,\n        getNextItem: c,\n        getPrevItem: d,\n        isFirstItemVisible: a,\n        isItemVisible: e => t.includes(e),\n        isLastItem: t => e.last() === u(t),\n        isLastItemVisible: s,\n        scrollNext: function (e, t, o) {\n          let {\n            duration: i,\n            ease: l,\n            boundary: a = null == n ? void 0 : n.current\n          } = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n          const s = null != e ? e : null == r ? void 0 : r.behavior;\n          return A(c(), s, t || \"start\", o || \"nearest\", {\n            boundary: a,\n            duration: null != i ? i : null == r ? void 0 : r.duration,\n            ease: null != l ? l : null == r ? void 0 : r.ease\n          });\n        },\n        scrollPrev: function (e, t, o) {\n          let {\n            duration: i,\n            ease: l,\n            boundary: a = null == n ? void 0 : n.current\n          } = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n          const s = null != e ? e : null == r ? void 0 : r.behavior;\n          return A(d(), s, t || \"end\", o || \"nearest\", {\n            boundary: a,\n            duration: null != i ? i : null == r ? void 0 : r.duration,\n            ease: null != l ? l : null == r ? void 0 : r.ease\n          });\n        },\n        scrollToItem: (e, t, o, i, l) => {\n          var a, s;\n          return A(e, null != t ? t : null == r ? void 0 : r.behavior, o, i, Object.assign(Object.assign({\n            boundary: null == n ? void 0 : n.current\n          }, l), {\n            duration: null !== (a = null == l ? void 0 : l.duration) && void 0 !== a ? a : null == r ? void 0 : r.duration,\n            ease: null !== (s = null == l ? void 0 : l.ease) && void 0 !== s ? s : null == r ? void 0 : r.ease\n          }));\n        },\n        visibleItems: t,\n        visibleItemsWithoutSeparators: l\n      };\n    }(k, V, M, {\n      duration: o,\n      ease: i,\n      behavior: l\n    }), [k, V, O]),\n          z = r.default.useCallback(() => Object.assign(Object.assign({}, _), {\n      initComplete: P,\n      items: k,\n      visibleItems: V,\n      scrollContainer: M\n    }), [_, P, k, V, M]),\n          [X, Y] = r.default.useState(z);\n\n    !function (_ref13) {\n      let {\n        cb: e = () => {},\n        condition: t,\n        hash: n\n      } = _ref13;\n      r.default.useEffect(() => {\n        t && e();\n      }, [n, t]);\n    }({\n      cb: () => s(X),\n      condition: function (_ref14) {\n        let {\n          cb: e,\n          condition: t\n        } = _ref14;\n        const [n, o] = r.default.useState(!1);\n        return r.default.useEffect(() => {\n          t && !n && (o(!0), e());\n        }, [t, n]), n;\n      }({\n        cb: () => a(X),\n        condition: P\n      }),\n      hash: JSON.stringify(V.concat(String(null == X ? void 0 : X.isFirstItemVisible)).concat(String(null == X ? void 0 : X.isLastItemVisible)))\n    }), r.default.useEffect(() => Y(z()), [z]), I.current = X;\n    const q = r.default.useCallback(e => v(X, e), [v, X]),\n          F = r.default.useCallback(e => h(X, e), [h, X]),\n          J = r.default.useMemo(() => `${u} ${x}`, [x]);\n    return r.default.createElement(\"div\", {\n      className: J,\n      onWheel: F,\n      onMouseDown: null == d ? void 0 : d(X),\n      onMouseUp: null == c ? void 0 : c(X),\n      onMouseMove: null == f ? void 0 : f(X)\n    }, r.default.createElement(D.Provider, {\n      value: X\n    }, E, r.default.createElement(m, {\n      className: g,\n      onScroll: q,\n      scrollRef: M\n    }, r.default.createElement(b, {\n      refs: N,\n      itemClassName: y,\n      separatorClassName: w\n    }, n)), C));\n  }, e.VisibilityContext = D, e.constants = v, e.getItemsPos = e => {\n    var t;\n\n    const n = (e => e.filter((e, t, n) => {\n      const r = 0 === t,\n            o = t === n.length - 1,\n            l = new RegExp(i).test(e);\n      return !((r || o) && l);\n    }))(e),\n          r = n[Math.floor(n.length / 2)];\n\n    return {\n      first: null == n ? void 0 : n[0],\n      center: r,\n      last: null === (t = n.slice(-1)) || void 0 === t ? void 0 : t[0]\n    };\n  }, e.slidingWindow = function (e, t) {\n    const n = R(e),\n          r = R(t);\n    return {\n      prev: () => P(function (e, t) {\n        const n = e.findIndex(e => e === (null == t ? void 0 : t[0])),\n              r = t.length,\n              o = n - r,\n              i = o < 0,\n              l = i ? 0 : o,\n              a = e.slice(l, i ? r : n);\n        return a.length === r ? a : e.slice(n, r);\n      }(n, r)),\n      next: () => P(function (e, t) {\n        const n = e.findIndex(e => {\n          var n;\n          return e === (null === (n = t.slice(-1)) || void 0 === n ? void 0 : n[0]);\n        }),\n              r = t.length,\n              o = n + r + 1,\n              i = o > e.length - 1,\n              l = i ? e.length - 1 : o,\n              a = e.slice(i ? l - r + 1 : n + 1, l);\n        return a.length === r ? a : e.slice(e.length - r, e.length + r);\n      }(n, r))\n    };\n  }, Object.defineProperty(e, \"__esModule\", {\n    value: !0\n  });\n});","map":null,"metadata":{},"sourceType":"script"}