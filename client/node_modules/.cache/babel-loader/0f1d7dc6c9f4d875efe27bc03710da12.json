{"ast":null,"code":"import { __assign } from \"tslib\";\nimport { useCallback, useMemo, useRef } from 'react';\nimport { ApolloError } from \"../../errors/index.js\";\nimport { useInternalState } from \"./useQuery.js\";\nimport { useApolloClient } from \"./useApolloClient.js\";\nimport { isNonEmptyArray } from \"../../utilities/index.js\";\nvar EAGER_METHODS = ['refetch', 'reobserve', 'fetchMore', 'updateQuery', 'startPolling', 'subscribeToMore'];\nexport function useLazyQuery(query, options) {\n  var internalState = useInternalState(useApolloClient(options && options.client), query);\n  var execOptionsRef = useRef();\n  var defaultOptions = internalState.client.defaultOptions.watchQuery;\n  var initialFetchPolicy = options && options.fetchPolicy || execOptionsRef.current && execOptionsRef.current.fetchPolicy || defaultOptions && defaultOptions.fetchPolicy || \"cache-first\";\n  var useQueryResult = internalState.useQuery(__assign(__assign(__assign({}, options), execOptionsRef.current), {\n    skip: !execOptionsRef.current\n  }));\n  var result = Object.assign(useQueryResult, {\n    called: !!execOptionsRef.current\n  });\n  var eagerMethods = useMemo(function () {\n    var eagerMethods = {};\n\n    var _loop_1 = function (key) {\n      var method = result[key];\n\n      eagerMethods[key] = function () {\n        if (!execOptionsRef.current) {\n          execOptionsRef.current = Object.create(null);\n          internalState.forceUpdate();\n        }\n\n        return method.apply(this, arguments);\n      };\n    };\n\n    for (var _i = 0, EAGER_METHODS_1 = EAGER_METHODS; _i < EAGER_METHODS_1.length; _i++) {\n      var key = EAGER_METHODS_1[_i];\n\n      _loop_1(key);\n    }\n\n    return eagerMethods;\n  }, []);\n  Object.assign(result, eagerMethods);\n  var execute = useCallback(function (executeOptions) {\n    var promise = result.reobserve(execOptionsRef.current = executeOptions ? __assign(__assign({}, executeOptions), {\n      fetchPolicy: executeOptions.fetchPolicy || initialFetchPolicy\n    }) : {\n      fetchPolicy: initialFetchPolicy\n    }).then(function (apolloQueryResult) {\n      apolloQueryResult = apolloQueryResult || internalState[\"getCurrentResult\"]();\n\n      if (apolloQueryResult.error || isNonEmptyArray(apolloQueryResult.errors)) {\n        var _a = result.observable.options.errorPolicy,\n            errorPolicy = _a === void 0 ? \"none\" : _a;\n\n        if (errorPolicy === \"none\") {\n          throw apolloQueryResult.error || new ApolloError({\n            graphQLErrors: apolloQueryResult.errors\n          });\n        }\n      }\n\n      return internalState.toQueryResult(apolloQueryResult);\n    }).then(function (queryResult) {\n      return Object.assign(queryResult, eagerMethods);\n    });\n    internalState.forceUpdate();\n    promise.catch(function () {});\n    return promise;\n  }, []);\n  return [execute, result];\n} //# sourceMappingURL=useLazyQuery.js.map","map":null,"metadata":{},"sourceType":"module"}